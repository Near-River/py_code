Shell俗称壳（用来区别于核），是指“提供使用者使用界面”的软件（命令解析器）
    通过键入文本与程序进行交互。
########################################################################################################################
布尔值：True、False
    运算符：and、or 和 not
空值：None
raw 字符串：内部字符不需要进行转义。用 r'...' 表示
多行字符串：用 '''...''' 表示
bytes 类型的每个字符都只占用一个字节
Python 把0、空字符串''和None看成 False，其他数值和非空字符串都看成 True
列表 list：有序集合，可以随时添加和删除其中的元素。表示形式：[?, ?, ?, ?]
    可以按照索引访问list，索引从 0 开始。
    添加：append()方法总是把新的元素添加到 list 的尾部。
        insert()方法，它接受两个参数，第一个参数是索引号，第二个参数是待添加的新元素。
    删除：pop()方法总是删掉list的最后一个元素，并且它还返回这个元素。
        pop()方法指定索引值可以删除指定索引位置的元素。
字符串的join()方法可以把一个 list 拼接成一个字符串。
元组 tuple：和 list 非常类似，但是，元组一旦创建完毕，就不能修改。表示形式：(?, ?, ?, ?)
    单元素 tuple 要多加一个逗号“,”。tuple所谓的“不变”是指每个元素的指向不变。
# Python代码的缩进规则：具有相同缩进的代码被视为代码块。
if-elif-else 分支结构
数据字典 dict：key:value结构。表示形式：{key:value, ...}
    函数：len()、get(key, default_val)、pop(key)
    特点：查找速度快、存储的key-value序对没有顺序、作为 key 的元素必须不可变。
set：元素没有重复，而且是无序的，不可存放可变对象。
    创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素。
    更新 set：添加元素 add()方法     删除元素 remove()方法（如果删除的元素不存在set中，remove()会报错）
    所以，对于不变对象来说，调用对象自身的任意方法，不会改变该对象自身的内容，而是创建新的对象并返回。
函数：定义一个函数要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号，然后，
    在缩进块中编写函数体，函数的返回值用 return 语句返回。
    函数可以返回多个值(返回值是一个元组 tuple)
    默认参数降低了函数调用的难度，可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。
        定义默认参数要牢记一点：默认参数必须指向不变对象
    可变参数：可变参数的名字前面有个 * 号，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数
    关键字参数：允许传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict
    命名关键字参数：限制关键字参数的名字，需要一个特殊分隔符 *，* 后面的参数被视为命名关键字参数
        如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符 *
# 迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。
    尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。用于结局栈溢出问题
迭代器：可以被next()函数调用并不断返回下一个值的对象 Iterator
    把list、dict、str等Iterable变成Iterator可以使用iter()函数
    Iterator对象表示的是一个数据流，可以将数据流看做是一个有序序列，其长度未知，只能不断调用next()函数按需获取下一个数据
########################################################################################################################
函数式编程：是一种抽象计算的编程模式
    特点：把计算视为函数而非指令；纯函数式编程：不需要变量，测试简单；支持高阶函数，代码简洁。
python 函数式编程特点：非纯函数式编程（允许有变量）；支持高阶函数（函数可以作为变量传入）
                    支持闭包（能够返回函数）；有限度的支持匿名函数
高阶函数：能够接收函数作为参数的函数
高阶函数特点：变量可以指向函数；函数名其实就是指向函数的变量
    返回函数可以把一些计算延迟执行
函数的作用域 LEGB: L>E>G>B 查找顺序优先级
    L：local 函数内部作用域，是最底层的单个函数里面；
    E：enclosing 函数内部与内嵌函数之间，是有内嵌函数的函数里面；
    G：global 全局作用域，是一个.py文件中；
    B：build-in 内置作用域，比如：tuple，list，dict。在所有.py文件中。
* 所有的函数都是可调用对象，函数执行完成后内部变量被回收
闭包（Closure）：内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数的情况
    要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。
匿名函数有个限制，就是只能有一个表达式，不写return，返回值就是该表达式的结果。
    关键字lambda 表示匿名函数，冒号前面的参数表示函数参数。
装饰器 @decorator：在运行时动态增加功能，而不改动函数本身的代码
Python的 decorator 本质上就是一个高阶函数，它接收一个函数作为参数，然后，返回一个新函数(装饰函数)。
    作用：极大地简化代码，避免每个函数编写相同代码
    打印日志：@log、检测性能：@performance、数据库事务：@transaction、URL路由：@post('/login')
    完善装饰器函数：Python内置的functools可以自动化完成把原函数的一些属性复制到新函数中。@functools.wraps(f)
偏函数：functools.partial可以把一个参数多的函数变成一个参数少的新函数，少的参数需要在创建时指定默认值。

模块和包：包下面必须有__init__.py文件，每层都必须要有（同名模块要放入不同包中）
    引入模块：（import math）可以认为math就是一个指向已导入模块的变量，通过该变量，我们可以访问
        math模块中所定义的所有公开的函数、变量和类。
        导入用到的math模块的某几个函数：from math import pow, log
        给函数起个“别名”来避免冲突：from logging import log as logger
# 当新版本的一个特性与旧版本不兼容时，该特性将会在旧版本中添加到__future__中
########################################################################################################################
面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，
计算机程序的执行就是一系列消息在各个对象之间传递。
面向对象编程：为类添加一个特殊的__init__()方法，当创建实例时，__init__()方法被自动调用。
    __init__() 方法的第一个参数必须是 self
    Python对属性权限的控制是通过属性名来实现的，如果一个属性由双下划线开头(__)，该属性就无法被外部访问。
    当实例属性和类属性重名时，实例属性优先级高，它将屏蔽掉对类属性的访问。
    实例的方法就是在类中定义的函数，它的第一个参数永远是 self，指向调用该方法的实例本身。
        实例方法其实也是属性，它实际上是一个函数对象。
    定义类方法：@classmethod，类方法的第一个参数将传入类本身，通常将参数名命名为 cls。
        类方法无法获得任何实例变量，只能获得类的引用。
类的继承：调用super(SuberClass, self).__init__(self,...)
多态：方法调用将作用在对象的实际类型上
    动态语言调用实例方法，不检查类型，只要方法存在，参数正确，就可以调用。
多重继承(MixIn)：目的是从两种继承树中分别选择并继承出子类，以便组合功能使用。
定制类：
    python中的特殊方法：__str__、__len__、__cmp__、__repr__ ...
        __str__()用于显示给用户，而__repr__()用于显示给开发人员
        特殊方法定义在class中、不需要直接调用、python 的某些函数或操作符会调用对应的特殊方法
        限制实例在运行时动态添加属性：__slots__
        类型转换：__int__、__float__ ...
    在没有找到属性的情况下，才调用__getattr__，已有的属性，不会在__getattr__中查找。
Enum可以把一组相关常量定义在一个class中，且class不可变，而且成员可以直接比较
动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的
type()动态创建类：要创建一个class对象，type()函数依次传入3个参数：
    class的名称；   继承的父类集合，组装成tuple；   class的方法名称与函数绑定
元类：metaclass允许你创建类或者修改类，metaclass是类的模板，所以必须从type类型派生
########################################################################################################################
错误和异常：
    try-except及else的使用、try-finally使用
    with语句与上下文管理：with语句实质是上下文管理
        上下文管理协议：必须包含方法__enter__()和__exit__()
        上下文管理器：定义执行with语句时要建立的运行时上下文，负责执行with语句块上下文中的进入和退出操作。
    自定义异常
    raise和assert语句：
        raise语句用于主动抛出异常，语法格式：raise[exception(args)] exception：异常类  args：描述异常信息的元组
        assert语句用于检测表达式是否为真，语法格式：raise[expression[,args]]
    标准异常：BaseException->KeyboardInterrupt、Exception、SystemExit ...
    自定义异常：自定义异常类继承至 Exception
单元测试：是一种以测试为驱动的开发模式，最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。
    在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。
    单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。
    单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。
########################################################################################################################
python 中文件是对象
    文件打开 open(name, mode, buf)
        codecs模块提供方法，创建指定编码格式的文本
    文件读取方式：
        read([size])：读取size个字节，默认读取全部字节
        readline([size])：读取一行
        readlines([size])：读取完文件，返回每一行所组成的列表
        iter(file)：遍历读入文件
    文件写入方式：
        write(str)：将字符串写入文件
        writelines(sequence_of_strings)：写多行到文件
    文件的指针：seek(offset, whence) offset：偏移量，whence：偏移相对位置
    标准文件：sys.stdin、sys.stdout、sys.stderr
StringIO和BytesIO是在内存中操作str和bytes的方法，使得和读写文件具有一致的接口
python 文件操作基本流程：
    得到文件对象->打开文件，得到文件描述符->对应文件驱动->操作硬件设备
使用 os 模块操作文件
   打开文件：os.open(filename, flag[, mode]) flag：打开文件方式
        flag：os.O_CREAT、os.O_RDONLY、os.O_WRONLY ．．．
   os.read(fd, buffersize) fd：文件描述符    os.write(fd, string)
   文件指针操作：os.lseek(fd, pos, how)      os.close(fd)
序列化：我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，
    marshalling，flattening等等。
    序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。
########################################################################################################################
python 正则表达式：
    1.使用单个字符串来描述匹配一系列符合其语法规则的字符串
    2.是对字符串操作的一种逻辑公式，用于处理文本和数据
    3.依次将表达式和文本中的字符比较，如果每一个字符都能匹配，则匹配成功、否则匹配失败。
    正则语法：
        普通字符        简单的转义字符
        标准字符集合(区分大小写，大写是相反的意思)：\d 、\w(匹配任意一个字母、数字或下划线) 、\s (匹配空白)、
            .(匹配任意一个字符，除了换行符)   // 匹配所有字符：使用[\s\S]
        自定义字符集合：[](匹配方括号中任意一个字符)
            正则表达式的特殊符号，被包含到中括号中，则失去特殊意义，除了 ^、- 之外
        量词：{n}、{m, n}、{m,}、? 相当于 {0,1}、+ 相当于 {1,}、*相当于 {0,}
            匹配模式默认是贪婪模式     非贪婪模式：在量词后加一个 ?
        字符边界(匹配位置)：^(与字符串开始的地方匹配)、$(与字符串结束的地方匹配)、\b(匹配一个单词边界)
            \A / \Z(指定的字符串必须出现在开头 / 结尾)
            \b：前面的字符和后面的字符不全是 \w
        选择符和分组：
            |：分支结构、"或"关系
            ()：捕获组      (?:P<name>)：分组起别名   (?P=name)：引用别名为name的分组匹配字符串
        反向引用(\number)：每一对()会分配一个编号，使用()的捕获根据左括号的顺序从1开始自动编号
            通过反向引用，可以对分组已捕获的字符串进行引用

##############################################################################################
爬虫：一段自动抓取互联网信息的程序
网络爬虫三大组成部分：
    爬虫调度端：启动，停止，监控运行情况；
    URL管理器：管理待爬取和已爬取的URL集合；
        基本功能：判断待添加URL是否为待爬取的，是则添加；
            判断是否还有待爬取的URL，有则获取并添加到待爬取的URL。
        实现方式：内存(set)；关系型数据库；缓存数据库。
    网页下载器：接收待爬取URL，将网页内容下载为字符串，传送给解析器；
    网页解析器：一方面解析出有价值的数据，一方面解析出其他关联URL，传回至URL管理器进行循环。
        模糊匹配：正则表达式
        结构化解析（DOM）：html.parser、Beautiful Soup、lxml
    开发爬虫步骤：
        确定目标；   分析目标（URL格式、数据格式、网页编码）；
        编写代码；   执行爬虫

##############################################################################################
python DB API包含的内容：cursor游标，connection数据库连接对象，exceptions异常处理

